<script>
  const game = document.getElementById('game');
  const size = 4;
  const cellSize = 75 + 6;
  let grid = Array(size).fill().map(() => Array(size).fill(0));
  let tiles = [];

  function drawBoard() {
    game.innerHTML = '';

    for (let i = 0; i < size * size; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      game.appendChild(cell);
    }

    tiles.forEach(t => {
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.textContent = t.value;
      tile.dataset.value = t.value;
      tile.style.transform = `translate(${t.x * cellSize}px, ${t.y * cellSize}px)`;
      game.appendChild(tile);
    });
  }

  function addTile() {
    let empty = [];
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        if (grid[y][x] === 0) empty.push({ x, y });
      }
    }
    if (empty.length === 0) return;

    const values = [2048, 1024, 512];
    let spot = empty[Math.floor(Math.random() * empty.length)];
    let value = values[Math.floor(Math.random() * values.length)];
    grid[spot.y][spot.x] = value;
  }

  function move(dx, dy) {
    let moved = false;
    let mergedThisTurn = Array(size).fill().map(() => Array(size).fill(false));

    function inBounds(x, y) {
      return x >= 0 && x < size && y >= 0 && y < size;
    }

    let order = [...Array(size).keys()];
    if (dx > 0 || dy > 0) order = order.reverse();

    for (let y of order) {
      for (let x of order) {
        let value = grid[y][x];
        if (value === 0) continue;

        let nx = x;
        let ny = y;

        while (true) {
          let nextX = nx + dx;
          let nextY = ny + dy;

          if (!inBounds(nextX, nextY)) break;

          if (grid[nextY][nextX] === 0) {
            grid[nextY][nextX] = grid[ny][nx];
            grid[ny][nx] = 0;
            nx = nextX;
            ny = nextY;
            moved = true;
          } else if (
            grid[nextY][nextX] === value &&
            !mergedThisTurn[nextY][nextX]
          ) {
            grid[nextY][nextX] = value / 2;
            grid[ny][nx] = 0;
            mergedThisTurn[nextY][nextX] = true;
            moved = true;
            break;
          } else {
            break;
          }
        }
      }
    }

    if (moved) {
      tiles = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (grid[y][x] !== 0) tiles.push({ x, y, value: grid[y][x] });
        }
      }
      addTile();
      drawBoard();
    }
  }

  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp') move(0, -1);
    if (e.key === 'ArrowDown') move(0, 1);
    if (e.key === 'ArrowLeft') move(-1, 0);
    if (e.key === 'ArrowRight') move(1, 0);
  });

  addTile();
  addTile();
  drawBoard();
</script>
